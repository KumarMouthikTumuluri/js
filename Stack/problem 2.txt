Step 1: If the scanned character is an operand, put it into postfix expression.
Step 2: If the scanned character is an operator and operator's stack is empty, push operator into operators' stack.
Step 3: If the operator's stack is not empty, there may be following possibilities.
>If the precedence of scanned operator is greater than the top most operator of operator's stack, push this operator into operator 's stack.
>If the precedence of scanned operator is less than the top most operator of operator's stack, pop the operators from operator's stack until we find a low precedence operator than the scanned character.
>If the precedence of scanned operator is equal then check the associativity of the operator. 
>If associativity left to right then pop the operators from stack until we find a low precedence operator. If associativity right to left then simply put into stack.

// If the scanned character is opening round bracket ( '(' ), push it into operator's stack.
// If the scanned character is closing round bracket ( ')' ), pop out operators from operator's stack until we find an opening bracket ('(' ).

 Repeat Step 1,2 and 3 till expression has character



Step 4: Now pop out all the remaining operators from the operator's stack and push into postfix expression.
Step 5: Exit





function checkOperator(op){
        switch (op)
        {
            case '+':
            case '-':
                return 1;

            case '*':
            case '/':
                return 2;

            case '^':
                return 3;

            case '(':
            case ')':
            case '{':
            case '}':
            case '[':
            case ']':
            
                return 4;
            
        }
    }

function infixToPostfix(exp) {
  let value = ''
  let s = new Stack()
  let postfix = new Stack()

  for (const key in exp) {
    if ( exp[key] === '{' || exp[key] === '}' || exp[key] === '[' || exp[key] === ']' || exp[key] === '(' || exp[key] === ')' || exp[key] === '+' || exp[key] === '-' || exp[key] === '*' || exp[key] === '/' ) {
      if (value !== '') {postfix.push(value);}
      if (s.length() === 0 && checkOperator(exp[key]) !== 4) {s.push(exp[key]);} 
	  else {
        if (checkOperator(exp[key]) !== 4) {
          innerLoop:
          while (s.length() > 0) {
            if (checkOperator(exp[key]) < checkOperator(s.peek())) {postfix.push(s.peek());s.pop();}
            else if (checkOperator(exp[key]) === checkOperator(s.peek())) {postfix.push(s.peek());s.pop();s.push(exp[key]);break innerLoop}
            else {
              if (checkOperator(exp[key]) !== 4) {s.push(exp[key])}
              break innerLoop
            }
          }
        }
      }
      value = ''
    } else {
      value += exp[key]
    }
  }

  while (s.length() > 0) {postfix.push(s.peek());s.pop();}
  return postfix;
}
let expression = "({a+[b*c]}-d)";
    console.log(infixToPostfix(expression));
